% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/http_wrappers.R
\name{.http_request}
\alias{.http_request}
\title{Why do we have tiny HTTP wrappers (.http_request, .http_perform, etc.)?}
\usage{
.http_request(url)
}
\description{
\enumerate{
\item Testability: one seam to mock
\itemize{
\item In tests we can patch these \emph{package-internal} functions with
\code{testthat::local_mocked_bindings(.env = asNamespace("gptr"))}.
\item If the code called httr2 directly (e.g. \code{httr2::req_perform()}),
those calls bypass package scope and are much harder to intercept
reliably (qualified calls, imports, different environments).
}
}
}
\details{
\enumerate{
\item Deterministic, network-free tests
\itemize{
\item We return fake responses and status codes from the wrappers so tests
never hit the network and are fully deterministic.
}
\item Decoupling from httr2
\itemize{
\item All usage of httr2 is centralized. If we ever swap HTTP libs or tweak
retry/backoff behavior, we change it in one place instead of hunting
through call sites.
}
\item Consistent policy and observability
\itemize{
\item Timeouts, retries, transient-error rules, and logging/metrics can be
applied uniformly inside these wrappers.
}
\item Clear failure mapping
\itemize{
\item Wrappers are the single place to translate transport errors into our
small, stable status vocabulary (“unreachable”, “non_json”, “http_503”).
}
}

Practical upshot:
\itemize{
\item Production code ONLY calls the .http_* wrappers (never httr2 directly).
\item Tests mock the .http_* wrappers; no need to patch httr2 or fight with \code{::}.
}
}
\examples{
Example(prod):
resp <- .http_request(url) |>
  .http_headers(Authorization = paste("Bearer", key)) |>
  .http_timeout(timeout) |>
  .http_retry(max_tries = 3, backoff = function(i) 0.2 * i, ...) |>
  .http_perform()
sc <- .http_status(resp)
j <- .http_body_json(resp, simplifyVector = FALSE)

Example(test):
testthat::local_mocked_bindings(
  .http_request = function(url) list(.url = url),
  .http_headers = function(req, ...) req,
  .http_timeout = function(req, ...) req,
  .http_retry = function(req, ...) req,
  .http_perform = function(req, ...) structure(list(.url = req$.url), class = "httr2_response"),
  .http_status = function(resp) 401L,
  .http_body_json = function(...) stop("boom"),
  .env = asNamespace("gptr")
)
#' now .list_openai_live("sk") yields status = "auth_error" without real I/O.
Request-side wrappers
}
\keyword{internal}
